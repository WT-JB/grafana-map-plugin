{"version":3,"sources":["../../src/utils/data_formatter.js"],"names":["filterEmptyAndZeroValues","data","hideEmpty","hideZero","_","filter","o","isNil","value","DataFormatter","series","panelDefaultPollutants","length","parsedPollutants","getSeries","getDataValues","setSeries","serieType","forEach","serie","id","split","serieName","alias","console","debug","datapoints","datapoint","index","valueAndType","parseFloat","push","latitudes","latitude","longitudes","longitude","values","ids","times","created_at","Error","pollutants_","pollutants","pollutant","key","poll","keyId","toString","newKey","dataValues","dataValue","locationLatitude","locationLongitude","type","time","thisPollutants","p","pollutantKey","error","log"],"mappings":"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","file":"data_formatter.js","sourcesContent":["import _ from 'lodash';\n\nexport default class DataFormatter {\n\n  getValues(series, panelDefaultPollutants) {\n    if (!series || series.length ==0)\n      return []\n\n    let parsedPollutants = this.getSeries(series, panelDefaultPollutants)\n\n    //processing only latitudes  \n    return this.getDataValues(parsedPollutants, panelDefaultPollutants);\n  }\n\n  getSeries(series, panelDefaultPollutants) {\n    let setSeries = {};\n    let serieType;\n\n    series.forEach((serie) => {\n      serieType = serie.id.split(':')[0];\n      \n      const serieName = serie.alias.split(': ')[1];\n      console.debug('serieType => '+serieType+', serieName => '+serieName)\n\n      if (!(setSeries[serieName])) {\n        setSeries[serieName] = [];\n      }\n\n      serie.datapoints.forEach((datapoint, index) => {\n        const valueAndType = {\n          'id': index,\n          'type': serieType,\n          'value': parseFloat(datapoint[0])\n        };\n\n        setSeries[serieName].push(valueAndType);\n      });\n    });\n\n    this.latitudes = setSeries.latitude;\n    this.longitudes = setSeries.longitude;\n    this.values = setSeries.value;\n    this.ids = setSeries.id;\n    this.times = setSeries.created_at;\n\n    if ( !(this.latitudes && this.longitudes && this.values && this.ids && this.times) ) {\n      throw new Error(\"Please make sure you selected 'Raw' in the aggregation type. 'latitude', 'longitude', 'value', 'id', 'created_at' are mandatory. You must also group by expression in order to create map layers.\");\n    }\n\n    let pollutants_ = {}\n    //Try to process pollutants\n    if(panelDefaultPollutants) {\n      setSeries.pollutants = [];\n\n      panelDefaultPollutants.forEach((pollutant) => {\n        let key = pollutant[0]\n\n        if (setSeries[key]) {\n          setSeries[key].forEach((poll) => {\n            const keyId = poll.id.toString();\n            const newKey = key + keyId;\n            if (!(pollutants_[newKey])) {\n              pollutants_[newKey] = { 'value': poll.value };\n            }\n          });\n//          delete setSeries[panelDefaultPollutants[0][0]];//?\n        }\n      });\n    }\n\n    return pollutants_;\n  }\n\n  getDataValues(parsedPollutants, panelDefaultPollutants) {\n    let dataValues = []\n\n    this.latitudes.forEach((value, index) => {\n      try {\n        let dataValue = {\n              locationLatitude: value.value,\n              locationLongitude: this.longitudes[index].value,\n              value: this.values[index].value,\n              type: this.values[index].type,\n              id: this.ids[index].value,\n              time: this.times[index].value,\n            };\n\n        let thisPollutants = [];\n\n        panelDefaultPollutants.forEach((p) => {\n          const pollutantKey = p[0] + value.id.toString();\n          if (parsedPollutants[pollutantKey]) {\n            thisPollutants.push({'name': p[0], 'value': parsedPollutants[pollutantKey].value});\n          }\n        });\n\n        dataValue.pollutants = thisPollutants\n\n        dataValues.push(dataValue);\n\n      } catch (error) {\n        console.log(\"Error:\")\n        console.log(error)\n        console.log(\"Parsing a data value:\")\n        console.log(dataValue)\n/*        throw new Error(\"Error parsing a data value\");*/\n      }\n    });\n    console.debug(dataValues)\n    return dataValues;\n  }\n}\n\n/*\n* Discard elements with value 0 or null\n* and hidden elements\n*/\nfunction filterEmptyAndZeroValues(data, hideEmpty, hideZero) {\n  return _.filter(data, (o) => { return !(hideEmpty && _.isNil(o.value)) && !(hideZero && o.value === 0) });\n}\n\nexport { filterEmptyAndZeroValues }"]}